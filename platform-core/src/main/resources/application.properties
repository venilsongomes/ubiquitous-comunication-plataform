spring.application.name=platform-core
# PostgreSQL Configuration
#spring.datasource.url=jdbc:postgresql://localhost:5433/ubiquitous_db
#spring.datasource.username=postgres
#spring.datasource.password=mortandela1010@1
#spring.datasource.driver-class-name=org.postgresql.Driver

# PostgreSQL Configuration
# Tenta ler da variável de ambiente SPRING_DATASOURCE_URL. Se não existir, usa localhost.
spring.datasource.url=${SPRING_DATASOURCE_URL:jdbc:postgresql://localhost:5432/ubiquitous_db}

# Tenta ler da variável de ambiente SPRING_DATASOURCE_USERNAME. Se não existir, usa admin.
spring.datasource.username=${SPRING_DATASOURCE_USERNAME:admin}

# Tenta ler da variável de ambiente SPRING_DATASOURCE_PASSWORD. Se não existir, usa password.
spring.datasource.password=${SPRING_DATASOURCE_PASSWORD:password}

spring.datasource.driver-class-name=org.postgresql.Driver

# JPA/Hibernate Configuration
# 'update' irá criar/atualizar as tabelas automaticamente baseado nas suas Entidades. Ótimo para dev.
spring.jpa.hibernate.ddl-auto=update
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Kafka Configuration
#spring.kafka.bootstrap-servers=localhost:29092
spring.kafka.bootstrap-servers=kafka:9092

# Um ID de grupo default para consumidores
spring.kafka.consumer.group-id=platform-group


# Configuração Connector do Telegram
telegram.bot.username=UbiquitousBot
telegram.bot.token=

minio.endpoint=http://localhost:9000
minio.access-key=minioadmin
minio.secret-key=minioadmin123
minio.bucket-name=ubiquitous-attachments

# Chave fixa para resolver o problema de injeção
application.security.jwt.secret-key=5367566B59703373367639792F423F4528482B4D6251655468576D5A71347437=
# Expiração: 24 horas (em milissegundos)
application.security.jwt.expiration=86400000

# --- Configuração do Actuator ---
# Expõe os endpoints (health e prometheus) via web
management.endpoints.web.exposure.include=health,prometheus

# Garante que as métricas do Kafka Consumer sejam ativadas
spring.kafka.consumer.properties.micrometer.client.id=platform-core
spring.kafka.producer.properties.micrometer.client.id=platform-core
spring.kafka.streams.properties.micrometer.client.id=platform-core
spring.kafka.admin.properties.micrometer.client.id=platform-core

# --- Configuração do Redis ---
spring.data.redis.host=${SPRING_DATA_REDIS_HOST:localhost}
spring.data.redis.port=${SPRING_DATA_REDIS_PORT:6379}

# --- Configuração gRPC ---
# Porta onde o servidor gRPC vai rodar
grpc.server.port=9090
# Nome do cliente (para o worker se conectar localmente)
grpc.client.presenceService.address=static://localhost:9090
grpc.client.presenceService.negotiation-type=plaintext

spring.kafka.consumer.group-id=platform-group-v3

springdoc.enable-hateoas=false

management.endpoints.web.exposure.include=health,prometheus
management.endpoints.web.base-path=/actuator

management.endpoint.prometheus.enabled=true
management.metrics.export.prometheus.enabled=true
management.endpoint.metrics.enabled=true





# --- OpenAPI/Swagger Configuration ---
# Metadata
#springdoc.info.title=Ubiquitous Communication Platform API (v1.0)
##springdoc.info.description=API for asynchronous messaging, presence tracking (Redis/gRPC), and secure file transfer (MinIO/S3).
#springdoc.info.version=1.0.0

# O SpringDoc deve procurar os Controllers neste pacote
#springdoc.packagesToScan=br.com.yourcompany.platformcore.controller

# URL de acesso ao painel Swagger UI
#springdoc.swagger-ui.path=/swagger-ui.html

#spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.hateoas.HateoasAutoConfiguration
